List challenge problems completed as part of the lab 6 handin, as well
as the problem number.  If you worked any previous lab challenges and
submitted them with this lab, list them here, along with the lab number.

1) Add 'struct inode' with metadata moved from 'struct File' which makes 'struct File' real dir entry:
-------------------------------------------------------------------------
struct File {
	char f_name[MAXNAMELEN];	// filename
	uint32_t i_ino; 		// inode number
	//off_t f_size;			// file size in bytes
	//uint32_t f_type;		// file type

	// Block pointers.
	// A block is allocated iff its value is != 0.
	//uint32_t f_direct[NDIRECT];	// direct blocks
	//uint32_t f_indirect;		// indirect block

	// Pad out to 256 bytes; must do arithmetic in case we're compiling
	// fsformat on a 64-bit machine.
	uint8_t f_pad[256 - MAXNAMELEN - 4 /*- 8 - 4*NDIRECT - 4*/];
} __attribute__((packed));	// required only on some 64-bit machines

struct inode {
	char f_name[MAXNAMELEN];	// filename
	off_t f_size;			// file size in bytes
	uint32_t f_type;		// file type

	// Block pointers.
	// A block is allocated iff its value is != 0.
	uint32_t f_direct[NDIRECT];	// direct blocks
	uint32_t f_indirect;		// indirect block

	uint32_t i_ino;
	uint32_t i_nlink;

	// Pad out to 256 bytes; must do arithmetic in case we're compiling
	// fsformat on a 64-bit machine.
	uint8_t f_pad[256 - MAXNAMELEN - 8 - 4*NDIRECT - 4 - 8];
} __attribute__((packed));	// required only on some 64-bit machines
------------------------------------------------------------------------

2) Modify fs/fsformat.c to allocate and generate inode on image file:

---------------------------------------------------------
uint32_t *ibitmap;
struct inode *itable;

static
uint32_t
alloc_inode()
{
	int i;
	for (i = 0; i < 32; i++) {
		if (ibitmap[i / 32] & (1 << (i % 32))) {
			ibitmap[i/32] &= ~(1<<(i%32));
			return i;
		}
	}
	panic("No free inode");
	return 0;
}

struct inode *
diradd(struct Dir *d, uint32_t type, const char *name)
{
	struct File *out = &d->ents[d->n++];
	if (d->n > MAX_DIR_ENTS)
		panic("too many directory entries");
	strcpy(out->f_name, name);
	//out->f_type = type;
	//return out;

	// Lab 5 - Challenge 4
	uint32_t i_ino = alloc_inode();
	struct inode *inode = &itable[i_ino];
	strcpy(inode->f_name, name);
	inode->f_type = type;
	inode->i_ino = i_ino;
	inode->i_nlink = 1;
	out->i_ino = i_ino;
	return inode;
}
---------------------------------------------------------

3) Modify fs/fs.c to replace struct File with inode.
  Too many modifications, here is only one place:

---------------------------------------------------------
int
file_create(const char *path, struct inode **pf)
{
	char name[MAXNAMELEN];
	int r;
	struct inode *dir, *ff;
        struct File *f;

	if ((r = walk_path(path, &dir, &ff, name)) == 0)
		return -E_FILE_EXISTS;
	if (r != -E_NOT_FOUND || dir == 0)
		return r;
	if ((r = dir_alloc_file(dir, &f)) < 0)
		return r;
	strcpy(f->f_name, name);

	// Lab 5 - Challenge 5
	uint32_t i_ino = alloc_inode();
	f->i_ino = i_ino;
	*pf = itable + i_ino;
	(*pf)->i_nlink = 1;
	(*pf)->i_ino = i_ino;
	strcpy((*pf)->f_name, name);

	//*pf = f;
	file_flush(dir);
	return 0;
}
---------------------------------------------------------

4) Share inode by incrementing i_nlink when creating hard link:

---------------------------------------------------------
int file_link(const char *srcpath, const char *dstpath)
{
	char name[MAXNAMELEN];
	int r;
	struct inode *dir, *ff;
        struct File *f;
	struct inode *src;

	if ((r = walk_path(dstpath, &dir, &ff, name)) == 0)
		return -E_FILE_EXISTS;
	if (r != -E_NOT_FOUND || dir == 0)
		return r;
	if ((r = dir_alloc_file(dir, &f)) < 0)
		return r;

	strcpy(f->f_name, name);

	// inode.f_name is useless if nlink > 1
	if ((r = walk_path(srcpath, &dir, &src, name)) < 0)
		return r;
	f->i_ino = src->i_ino;
	src->i_nlink++;

	flush_block(src);

	file_flush(dir);
	return 0;
}
----------------------------------------------------------

5) Add user/ln.c as 'ln' command source file:

-------------------------------------
#include <inc/lib.h>

void
ln(const char *src, const char *dst)
{
	link(src, dst);
}

void
umain(int argc, char **argv)
{
	ln(argv[1], argv[2]);
}
------------------------------------

6) Test 'ln' command:
--------------------------------------
student@vl56:~/lab$ make run-icode-nox
$ ls
bin
sbin
newmotd
motd
robig
lorem
script
testshell.key
testshell.sh

$ ln motd motd2

$ ls
bin
sbin
newmotd
motd
robig
lorem
script
testshell.key
testshell.sh
motd2
---------------------------------------
